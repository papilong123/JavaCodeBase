# MVCC原理
关系型数据库中处理事务冲突的主要手段，目的是提高数据库高并发场景下的吞吐性能。

## MVCC出现背景
4种事务隔离级别：  
----------读未提交  
脏读  
----------读已提交  
不可重复读  
----------可重复读  
幻读  
----------串行化  

脏读：一个事务读取到了另外一个事务没有提交的数据
不可重复读：在同一事务中，两次读取同一数据，得到内容不同
幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同  

MySQL默认**可重复读**，可以解决脏读和不可重复读的问题，但不能解决幻读问题，串行化虽然可以解决幻读问题，但会大幅降低事务并发能力  

MVCC通过**乐观锁**解决不可重复读和幻读问题，它可以在大多数情况下替代行级锁，降低系统的开销

**乐观锁**：每次取数据的时候都认为他人不会对其修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**悲观锁**：每次取数据的时候都认为他人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）

## 是什么，解决了什么?

通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本

>我们可以**通过比较版本号决定数据是否显示出来**，读取数据的时候不需要加锁也可以保证事务的隔离效果

1. **读写之间阻塞的问题**。通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力
2. **降低了死锁的概率**。这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行
3. **解决一致性读的问题**。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果

**快照读**：读取的是快照数据，不加锁的简单的SELECT都属于快照读（只是普通的读操作）

**当前读**：当前读就是读取最新数据，而不是历史版本的数据。加锁的SELECT，或者对数据进行增删改都会进行当前读（包括加锁的读取和DML操作）

https://blog.csdn.net/w892824196/article/details/109701966

